#include <cstdint>
#include <map>
#include <functional>
#include <bitset>
//get_reg, set_reg - по умолчанию возвращают int64_t
//TODO: верно ли сдвиги тут генерятся?
//логический сдвиг в с++ - для беззнаковых, арифметический - для знаковых
using InstructionHandler = std::function<void(uint64_t)>;
<% instruction_set = InstructionSet.new('riscv_instructions.yaml')%>
std::map<uint32_t, InstructionHandler> instruction_map = {
<%= instruction_set.generate_map %>
};
<% format_args = instruction_set.get_args('I')
 instruction_set.find_by_format('I').each do |instruction_name, details| %>
void <%= instruction_name %> (uint64_t instruction_code) { 
  <%=details.key?('type') ? details['type'] : 'int64_t'%> imm;
  int rd, rs1;
  rd = (instruction_code & <%= format_args['rd'][:mask] %>) >> <%= format_args['rd'][:start_bit] %>;
  rs1 = (instruction_code & <%= format_args['rs1'][:mask] %>) >> <%= format_args['rs1'][:start_bit] %>;
  imm = (instruction_code & <%= format_args['imm'][:mask] %>) >> <%= format_args['imm'][:start_bit] %>;
  <%
    type_cast = details.key?('type') ? '(int64_t)' : ''
    uint_cast = details.key?('type') ? '(uint64_t)' : ''
    shamt_expr = details.key?('shamt') ? '(imm & 0x3F)' : 'imm'
    if details.key?('load')
      parts = ["set_reg(rd, (int64_t)(load_mem((get_reg(rs1) + imm), ", details['load'], ")));"]
    else
      parts = [
        "set_reg(rd, ",
        type_cast,
        "(",
        uint_cast,
        "(get_reg(rs1)) ",
        details['operator'],
        " ",
        shamt_expr,
        " ",
        details['afterop'],
        "));"
      ]
    end
  %>
  <%= parts.join('') %>
}
<% end %>

<% format_args = instruction_set.get_args('R')  
 instruction_set.find_by_format('R').each do |instruction_name, details| %>
void <%= instruction_name %> (uint64_t instruction_code) {
  int rd, rs1, rs2;
  rd = (instruction_code & <%= format_args['rd'][:mask] %>) >> <%= format_args['rd'][:start_bit] %>;
  rs1 = (instruction_code & <%= format_args['rs1'][:mask] %>) >> <%= format_args['rs1'][:start_bit] %>;
  rs2 = (instruction_code & <%= format_args['rs2'][:mask] %>) >> <%= format_args['rs2'][:start_bit] %>;
  <%
    type_cast = details.key?('type') ? ' (int64_t)' : ''
    uint_cast = details.key?('type') ? '(uint64_t)' : ''
    
    parts = [
      'set_reg(rd, ',
      type_cast,
      '(',
      uint_cast,
      '(get_reg(rs1)) ',
      details['operator'],
      type_cast,
      ' (get_reg(rs2))) ',
      details['afterop'],
      ');'
    ]
  %>
  <%= parts.join('') %>
}
<%end%>

<% format_args = instruction_set.get_args('U')  
 instruction_set.find_by_format('U').each do |instruction_name, details| %>
void <%= instruction_name %> (uint64_t instruction_code) {
  int64_t rd, imm;
  rd = (instruction_code & <%= format_args['rd'][:mask] %>) >> <%= format_args['rd'][:start_bit] %>;
  imm = (instruction_code & <%= format_args['imm'][:mask] %>) >> <%= format_args['imm'][:start_bit] %>;

  set_reg(rd, <%= details['preop'] %> imm << 12);
}
<%end%>
// S-type
<% format_args = instruction_set.get_args('S')
instruction_set.find_by_format('S').each do |insts_name, details| %>
void <%=insts_name%> (uint64_t instruction_code) {
  int64_t imm_1, imm_2, rs1, rs2;
  rs1 = (instruction_code & <%= format_args['rs1'][:mask] %>) >> <%= format_args['rs1'][:start_bit] %>;
  rs2 = (instruction_code & <%= format_args['rs2'][:mask] %>) >> <%= format_args['rs2'][:start_bit] %>;
  imm_1 = (instruction_code & <%= format_args['imm_1'][:mask] %>) >> <%= format_args['imm_1'][:start_bit] %>;
  imm_2 = (instruction_code & <%= format_args['imm_2'][:mask] %>) >> <%= format_args['imm_2'][:start_bit] %>;

  uint64_t offset_high, offset_low;
  offset_high = (instruction_code & <%=format_args['imm_2'][:mask]%>) >> <%=format_args['imm_2'][:start_bit]%>;
  offset_low = (instruction_code & <%=format_args['imm_1'][:mask]%>) >> <%=format_args['imm_1'][:start_bit]%>;

  std::bitset<<%=details['store']%>> bits;
  uint<%=details['store']%>_t mask = bits.to_ulong();
  uint<%=details['store']%>_t rs2_value = get_reg(rs2) & mask;

  int64_t offset = ((int32_t)(offset_high) << 5) | offset_low;
  int64_t address = get_reg(rs1) + offset;

  store_mem(address, rs2_value);
}
<%end%>
//J-type
<% format_args = instruction_set.get_args('J')
instruction_set.find_by_format('J').each do |insts_name, details| %>
void <%=insts_name%> (uint64_t instruction_code) {

  set_reg(rd, get_pc() + 4);
}
<%end%>


